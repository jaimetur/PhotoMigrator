name: Build Executables for Multiple Platforms

on:
  push:
    branches:
      - main
    paths-ignore:
      - '_built_versions/**'  # Ignore any changes in _built_versions
  workflow_dispatch:  # Allows manual execution of the workflow

jobs:
  build:
    strategy:
      matrix:
#        os: [ubuntu-20.04, macos-latest, windows-latest]  # macos-latest
#        os: [ubuntu-20.04]  # macos-latest
        os: [macos-latest]  # macos-latest
#        os: [ubuntu-20.04, windows-latest]  # macos-latest
#        os: [macos-latest, windows-latest]  # macos-latest
        arch: [x86_64, arm64]  # amd64 and arm64
#        arch: [arm64]  # amd64 and arm64
        exclude:
          - os: windows-latest
            arch: arm64  # Windows is only compiled for x86 (32/64-bit)
        python-version: ["3.10.10"]

    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v3

      - name: Show Matrix Info
        run: |
          echo "OS: ${{ matrix.os }}"
          echo "Architecture: ${{ matrix.arch }}"
        shell: bash

      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python-version }}

      # Compile for Linux with different architectures
      - name: Compile for Linux (arm64) with Docker and QEMU
        if: matrix.os == 'ubuntu-20.04' && matrix.arch == 'arm64'
        run: |
          apt update
          apt install -y qemu qemu-user-static
          docker run --rm --platform linux/arm64 -v ${{ github.workspace }}:/workspace -w /workspace/src python:3.10 bash -c "
                sudo apt update && sudo apt install -y gcc-aarch64-linux-gnu &&
                python3 _compile.py"
        shell: bash
      - name: Compile for Linux (amd64)
        if: matrix.os == 'ubuntu-20.04' && matrix.arch != 'arm64'
        run: |
          python3 _compile.py
        shell: bash

      # Compile for macOS with different architectures
      - name: Compile for MacOS (all architectures)
        if: matrix.os == 'macos-latest'
        run: |
          cd src
          arch -${{ matrix.arch }} python3 _compile.py
        shell: bash

      # Compile for Windows (and64)
      - name: Compile for Windows (amd64)
        if: matrix.os == 'windows-latest'
        run: |
          cd src
          python _compile.py
        shell: cmd

#      # Extract metadata and build paths
#      - name: Extract Metadata and Create Path Variables
#        run: |
#          SCRIPT_NAME=$(awk -F '"' '/SCRIPT_NAME/ {print $2}' src/OrganizeTakeoutPhotos.py)
#          SCRIPT_VERSION=$(awk -F '"' '/SCRIPT_VERSION/ {print $2}' src/OrganizeTakeoutPhotos.py)
#          SCRIPT_NAME_VERSION="${SCRIPT_NAME}_${SCRIPT_VERSION}"
#
#          ARCH="${{ matrix.arch }}"
#          OS_TAG="linux"  # Default value
#
#          # Determine tag based on the operating system
#          if [[ "${{ matrix.os }}" == *"windows"* ]]; then
#            OS_TAG="windows"
#          elif [[ "${{ matrix.os }}" == *"macos"* ]]; then
#            OS_TAG="macos"
#          fi
#
#          # Replace x86_64 with amd64
#          if [ "$ARCH" == "x86_64" ]; then
#            ARCH="amd64"
#          fi
#
#          # Create the artifact name with the dynamic tag
#          ARCHIVE_NAME="${SCRIPT_NAME_VERSION}_${OS_TAG}_${ARCH}.zip"
#
#          # Determine the path of the generated file
#          if [ -d "_built_versions/${SCRIPT_NAME_VERSION}" ]; then
#            ARCHIVE_PATH=$(realpath "_built_versions/${SCRIPT_NAME_VERSION}/")
#          else
#            ARCHIVE_PATH=$(pwd)/_built_versions/${SCRIPT_NAME_VERSION}
#          fi
#          ARCHIVE_PATH_NAME="${ARCHIVE_PATH}/${ARCHIVE_NAME}"
#          ARCHIVE_FINAL_PATH="_built_versions/${SCRIPT_NAME_VERSION}/"
#          ARCHIVE_FINAL_PATH_NAME="${ARCHIVE_FINAL_PATH}${ARCHIVE_NAME}"
#
#          # Print variables in screen
#          echo "ARCHIVE_NAME=${ARCHIVE_NAME}"
#          echo "ARCHIVE_PATH=${ARCHIVE_PATH}"
#          echo "ARCHIVE_PATH_NAME=${ARCHIVE_PATH_NAME}"
#          echo "ARCHIVE_FINAL_PATH=${ARCHIVE_FINAL_PATH}"
#          echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_FINAL_PATH_NAME}"
#
#          # Save variables in the environment
#          echo "ARCHIVE_NAME=${ARCHIVE_NAME}" >> $GITHUB_ENV
#          echo "ARCHIVE_PATH=${ARCHIVE_PATH}" >> $GITHUB_ENV
#          echo "ARCHIVE_PATH_NAME=${ARCHIVE_PATH_NAME}" >> $GITHUB_ENV
#          echo "ARCHIVE_FINAL_PATH=${ARCHIVE_FINAL_PATH}" >> $GITHUB_ENV
#          echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_FINAL_PATH_NAME}" >> $GITHUB_ENV
#
#          # For Windows, convert paths
#          if [ "$RUNNER_OS" == "Windows" ]; then
#            echo "ARCHIVE_PATH_NAME=$(echo ${ARCHIVE_PATH_NAME} | sed 's/\//\\/g')" >> $GITHUB_ENV
#          fi
#        shell: bash

      - name: Extract Archive Path from filename.txt (Cross-Platform)
        run: |
          if [ "$RUNNER_OS" == "Windows" ]; then
            $path = Get-Content src/filename.txt | Select-String -Pattern "."
            echo "ARCHIVE_FINAL_PATH_NAME=$path" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            Write-Output "Extracted Path (Windows): $path"
          else
            ARCHIVE_PATH=$(cat src/filename.txt)
            echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_PATH}" >> $GITHUB_ENV
            echo "Extracted Path (Linux/macOS): ${ARCHIVE_PATH}"
          fi

      - name: Debug File Existence
        run: |
          ls -l _built_versions/OrganizeTakeoutPhotos_v2.3.0
          if [ ! -f ${{ env.ARCHIVE_FINAL_PATH_NAME }} ]; then
            echo "Error: Archivo no encontrado -> ${{ env.ARCHIVE_FINAL_PATH_NAME }}"
            exit 1
          fi
        shell: bash

      - name: Debug SHA Retrieval
        run: |
          SHA_DEV=$(curl -s -H "Authorization: token ${{ secrets.GH_PAT }}" \
          https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos-dev/contents/${ARCHIVE_FINAL_PATH_NAME} | \
          grep '"sha"' | awk -F '"' '{print $4}')

          echo "SHA_DEV: $SHA_DEV"
          if [ -z "$SHA_DEV" ]; then
            echo "Archivo no encontrado en el repo dev o token inválido."
            curl -v -H "Authorization: token ${{ secrets.GH_PAT }}" \
            https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos-dev/contents/${ARCHIVE_FINAL_PATH_NAME}
            exit 1
          fi
        shell: bash

      - name: Debug Base64 Output
        run: |
          echo "Base64 Artifact Length: ${#BASE64_ARTIFACT}"
          echo "${BASE64_ARTIFACT:0:100}"  # Muestra los primeros 100 caracteres
          if [ -z "$BASE64_ARTIFACT" ]; then
            echo "Error: El archivo codificado está vacío."
            exit 1
          fi
        shell: bash

      - name: Debug Path Variable
        run: |
          echo "Ruta final del archivo: ${{ env.ARCHIVE_FINAL_PATH_NAME }}"
        shell: bash




      # Upload the compiled compressed file to the corresponding GitHub repositories
      - name: Upload artifact to GitHub repos (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          echo "Uploading file '${ARCHIVE_FINAL_PATH_NAME}' to dev and prod repositories..."

          # Base64 Encoding for Linux/macOS
          BASE64_ARTIFACT=$(cat ${{ env.ARCHIVE_FINAL_PATH_NAME }} | base64 | tr -d '\n')
          echo "BASE64_ARTIFACT=$BASE64_ARTIFACT" >> $GITHUB_ENV

          # Parameters
          COMMIT_MESSAGE="Added from GitHub Actions"

          # Get the sha of the file in dev
          SHA_DEV=$(curl -s -H "Authorization: token ${{ secrets.GH_PAT }}" \
            https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos-dev/contents/${ARCHIVE_FINAL_PATH_NAME} | \
            grep '"sha"' | awk -F '"' '{print $4}')

          if [ -z "$SHA_DEV" ]; then
                echo "El archivo no existe en el repo dev. Se creará uno nuevo."
                SHA_DEV=null
          fi
          
          # Upload to dev repo
          curl -X PUT \
            -H "Authorization: token ${{ secrets.GH_PAT }}" \
            -H "Content-Type: application/json" \
            -d @- https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos-dev/contents/${ARCHIVE_FINAL_PATH_NAME} <<EOF
          {
            "message": "${COMMIT_MESSAGE}",
            "content": "${BASE64_ARTIFACT}",
            "branch": "main",
            "sha": "${SHA_DEV}"
          }
          EOF

          # Get the sha of the file in prod
          SHA_PROD=$(curl -s -H "Authorization: token ${{ secrets.GH_PAT }}" \
            https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos/contents/${ARCHIVE_FINAL_PATH_NAME} | \
            grep '"sha"' | awk -F '"' '{print $4}')

          if [ -z "SHA_PROD" ]; then
                echo "El archivo no existe en el repo prod. Se creará uno nuevo."
                SHA_PROD=null
          fi
          
          # Upload to prod repo
          curl -X PUT \
            -H "Authorization: token ${{ secrets.GH_PAT }}" \
            -H "Content-Type: application/json" \
            -d @- https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos/contents/${ARCHIVE_FINAL_PATH_NAME} <<EOF
          {
            "message": "${COMMIT_MESSAGE}",
            "content": "${BASE64_ARTIFACT}",
            "branch": "main",
            "sha": "${SHA_PROD}"
          }
          EOF
        shell: bash


      - name: Upload artifact to GitHub repos (Windows)
        if: runner.os == 'Windows'
        run: |
          Write-Host "Uploading file '${{ env.ARCHIVE_FINAL_PATH_NAME }}' to dev and prod repositories..."

          # Base64 Encoding for Windows
          $BASE64_ARTIFACT = [Convert]::ToBase64String([IO.File]::ReadAllBytes("${{ env.ARCHIVE_FINAL_PATH_NAME }}"))
          echo "BASE64_ARTIFACT=$BASE64_ARTIFACT" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

          # Parameters
          $COMMIT_MESSAGE = "Added from GitHub Actions"

          # Get the sha of the file in dev
          $SHA_DEV = (Invoke-RestMethod -Uri "https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos-dev/contents/${{ env.ARCHIVE_FINAL_PATH_NAME }}" -Headers @{Authorization="token ${{ secrets.GH_PAT }}"}).sha

          # Upload to dev repo
          Invoke-RestMethod -Method Put -Uri "https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos-dev/contents/${{ env.ARCHIVE_FINAL_PATH_NAME }}" -Headers @{Authorization="token ${{ secrets.GH_PAT }}"} -Body (ConvertTo-Json -Compress @{
            message = $COMMIT_MESSAGE
            content = $BASE64_ARTIFACT
            branch = "main"
            sha = $SHA_DEV
          })

          # Get the sha of the file in prod
          $SHA_PROD = (Invoke-RestMethod -Uri "https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos/contents/${{ env.ARCHIVE_FINAL_PATH_NAME }}" -Headers @{Authorization="token ${{ secrets.GH_PAT }}"}).sha

          # Upload to prod repo
          Invoke-RestMethod -Method Put -Uri "https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos/contents/${{ env.ARCHIVE_FINAL_PATH_NAME }}" -Headers @{Authorization="token ${{ secrets.GH_PAT }}"} -Body (ConvertTo-Json -Compress @{
            message = $COMMIT_MESSAGE
            content = $BASE64_ARTIFACT
            branch = "main"
            sha = $SHA_PROD
          })
        shell: pwsh




#      # Upload the compiled compressed file to the Actions task
#      - name: Archive Artifacts
#        uses: actions/upload-artifact@v4
#        with:
#          name: ${{ env.ARCHIVE_NAME }}
#          path: ${{ env.ARCHIVE_FINAL_PATH }}