name: Build Executables for Multiple Platforms

on:
  push:
    branches:
      - main
    paths-ignore:
      - '_built_versions/**'  # Ignora cualquier cambio en _built_versions
  workflow_dispatch:  # Permite ejecución manual del workflow

jobs:
  build:
    strategy:
      matrix:
#        os: [ubuntu-20.04, macos-latest, windows-latest]  # macos-latest
        os: [ubuntu-20.04]  # macos-latest
#        arch: [x86_64, arm64]  # amd64 y arm64
        arch: [x86_64]  # amd64 y arm64
        exclude:
          - os: windows-latest
            arch: arm64  # Windows solo se compila para x86 (32/64-bit)
        python-version: ["3.10.10"]

    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python-version }}

      # Compilación para Linux y macOS
      - name: Compile for Linux and MacOS
        if: matrix.os != 'windows-latest'
        run: |
          cd src
          python3 _compile.py
        shell: bash

      # Compilación para Windows
      - name: Compile for Windows
        if: matrix.os == 'windows-latest'
        run: |
          cd src
          python _compile.py
        shell: cmd

      # Extraer metadatos y construir paths
      - name: Extract Metadata and Create Path Variables
        run: |
          SCRIPT_NAME=$(grep -oP 'SCRIPT_NAME\s*=\s*"\K[^"]+' src/OrganizeTakeoutPhotos.py)
          SCRIPT_VERSION=$(grep -oP 'SCRIPT_VERSION\s*=\s*"\K[^"]+' src/OrganizeTakeoutPhotos.py)
          SCRIPT_NAME_VERSION="${SCRIPT_NAME}_${SCRIPT_VERSION}"

          ARCH="${{ matrix.arch }}"
          OS_TAG="linux"  # Valor por defecto

          # Determinar etiqueta según el sistema operativo
          if [[ "${{ matrix.os }}" == *"windows"* ]]; then
            OS_TAG="windows"
          elif [[ "${{ matrix.os }}" == *"macos"* ]]; then
            OS_TAG="macos"
          fi

          # Reemplazar x86_64 por amd64
          if [ "$ARCH" == "x86_64" ]; then
            ARCH="amd64"
          fi

          # Crear el nombre del artefacto con la etiqueta dinámica
          ARCHIVE_NAME="${SCRIPT_NAME_VERSION}_${OS_TAG}_${ARCH}.zip"
          
          # Determinar la ruta del archivo generado
          if [ -d "_built_versions/${SCRIPT_NAME_VERSION}" ]; then
            ARCHIVE_PATH=$(realpath "_built_versions/${SCRIPT_NAME_VERSION}/")
          else
            ARCHIVE_PATH=$(pwd)/_built_versions/${SCRIPT_NAME_VERSION}
          fi
          ARCHIVE_PATH_NAME="${ARCHIVE_PATH}/${ARCHIVE_NAME}"
          ARCHIVE_FINAL_PATH="_built_versions/${SCRIPT_NAME_VERSION}/"
          ARCHIVE_FINAL_PATH_NAME="${ARCHIVE_FINAL_PATH}${ARCHIVE_NAME}"
          
          # Guardar variables en el entorno
          echo "ARCHIVE_NAME=${ARCHIVE_NAME}"
          echo "ARCHIVE_PATH=${ARCHIVE_PATH}"
          echo "ARCHIVE_PATH_NAME=${ARCHIVE_PATH_NAME}"
          echo "ARCHIVE_FINAL_PATH=${ARCHIVE_FINAL_PATH}"
          echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_FINAL_PATH_NAME}"
          
          echo "ARCHIVE_NAME=${ARCHIVE_NAME}" >> $GITHUB_ENV
          echo "ARCHIVE_PATH=${ARCHIVE_PATH}" >> $GITHUB_ENV
          echo "ARCHIVE_PATH_NAME=${ARCHIVE_PATH_NAME}" >> $GITHUB_ENV
          echo "ARCHIVE_FINAL_PATH=${ARCHIVE_FINAL_PATH}" >> $GITHUB_ENV
          echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_FINAL_PATH_NAME}" >> $GITHUB_ENV

          # Para Windows, convertir rutas
          if [ "$RUNNER_OS" == "Windows" ]; then
            echo "ARCHIVE_PATH_NAME=$(echo ${ARCHIVE_PATH_NAME} | sed 's/\//\\/g')" >> $GITHUB_ENV
          fi
        shell: bash

      # Subir el fichero compilado comprimido a los repositorios Github correspondientes
      - name: Upload folder to GitHub repos
        run: |
          echo "Subiendo carpeta completa a _built_versions..."

          REPO_PATH="_built_versions/${{ env.ARCHIVE_NAME }}"
          COMMIT_MESSAGE="Add artifact from GitHub Actions"

          # Subir la carpeta completa de forma recursiva
          for file in $(find ${{ env.ARCHIVE_PATH }} -type f); do
            RELATIVE_PATH=$(realpath --relative-to="${{ env.ARCHIVE_PATH }}" "$file")
            echo "Subiendo archivo: $RELATIVE_PATH"

            # Convertir archivo a base64
            BASE64_ARTIFACT=$(base64 -w 0 "$file")

            # Subir al repo dev
            curl -X PUT \
              -H "Authorization: token ${{ secrets.GH_PAT }}" \
              -H "Content-Type: application/json" \
              -d @- https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos-dev/contents/${REPO_PATH}/${RELATIVE_PATH} <<EOF
            {
              "message": "${COMMIT_MESSAGE}",
              "content": "${BASE64_ARTIFACT}",
              "branch": "${{ github.ref_name }}"
            }
            EOF

            # Subir al repo prod
            curl -X PUT \
              -H "Authorization: token ${{ secrets.GH_PAT }}" \
              -H "Content-Type: application/json" \
              -d @- https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos/contents/${REPO_PATH}/${RELATIVE_PATH} <<EOF
            {
              "message": "${COMMIT_MESSAGE}",
              "content": "${BASE64_ARTIFACT}",
              "branch": "${{ github.ref_name }}"
            }
            EOF
          done




#      # Subir los ejecutables generados usando la ruta completa
#      - name: Archive Artifacts
#        uses: actions/upload-artifact@v4
#        with:
#          name: ${{ env.ARCHIVE_NAME }}
#          path: ${{ env.ARCHIVE_FINAL_PATH }}