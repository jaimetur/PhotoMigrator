name: Build Executables for Multiple Platforms

on:
  workflow_dispatch:      # Allows manual execution of the workflow
  #push:                   # Ejecución tras push en main, excepto en los path-ignore
    #branches:
      #- main
    #paths-ignore:
      #- '_built_versions/**'  # Ignore any changes in _built_versions
      #- .gitignore
      #- gpth*/**
      #- exif*/**
      #- .idea/**
      #- _src_versions/**
      #- _buildt_versions/**
      #- .github/**
#  schedule:               # Ejecución diaria a las 2 AM UTC
#    - cron: '0 2 * * *'

jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]  # os list
        arch: [x86_64, arm64]  # arch list
        exclude:
          - os: windows-latest
            arch: arm64  # Windows is only compiled for x86 (32/64-bit)
        python-version: ["3.10.10"]

    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v3

      # Set up Python
      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python-version }}

      # 1. - Compile for All Operating System (Linux, MacOS, Windows) and All Arquitectures (amd64, arm64)
      - name: 1. - Compile for All Operating System (Linux, MacOS, Windows) and All Arquitectures (amd64, arm64)
        run: |
          echo "::group::Compile for ${{ matrix.os }} - ${{ matrix.arch }}"
                    
          # Compile for macOS (any architecture)
          if [[ "${{ matrix.os }}" == *"macos"* ]]; then
            cd src
            arch -${{ matrix.arch }} python3 _compile.py
          
          # Compile for Windows (amd64)
          elif [[ "${{ matrix.os }}" == *"windows"* ]]; then
            cd src
            python _compile.py
               
          # Compile for Linux (arm64)
          elif [[ "${{ matrix.os }}" == *"ubuntu"* ]] && [ "${{ matrix.arch }}" == "arm64" ]; then
            sudo apt-get update
            sudo apt-get install -y software-properties-common
            sudo add-apt-repository universe
            sudo add-apt-repository multiverse
            sudo add-apt-repository restricted
            sudo apt-get update
            sudo apt-get install -y qemu-user-static binfmt-support
            docker run --rm --platform linux/arm64 -v ${{ github.workspace }}:/workspace -w /workspace/src ubuntu:20.04 bash -c "
                apt update && apt install -y gcc-aarch64-linux-gnu python3 python3-pip &&
                python3 _compile.py
                "
          
          # Compile for Linux (amd64)
          elif [[ "${{ matrix.os }}" == *"ubuntu"* ]] && [ "${{ matrix.arch }}" != "arm64" ]; then
            docker run --rm --platform linux/amd64 -v ${{ github.workspace }}:/workspace -w /workspace/src jaimetur/centos-amd64:7 bash -c "
                cd src
                python3 _compile.py
                "
          fi

          echo "::endgroup::"
        shell: bash

      # 2a. Extract ARCHIVE_FINAL_PATH_NAME from filename.txt (Linux/macOS)
      - name: 3a. Extract ARCHIVE_FINAL_PATH_NAME from filename.txt (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          ARCHIVE_PATH=$(cat src/filename.txt)
          echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_PATH}" >> $GITHUB_ENV
          echo "ARCHIVE_FINAL_PATH_NAME (Linux/macOS): ${ARCHIVE_PATH}"

      # 2b. Extract ARCHIVE_FINAL_PATH_NAME from filename.txt (Windows)
      - name: 3b. Extract ARCHIVE_FINAL_PATH_NAME from filename.txt (Windows)
        if: runner.os == 'Windows'
        run: |
          $path = Get-Content src/filename.txt | Select-String -Pattern "."
          echo "ARCHIVE_FINAL_PATH_NAME=$path" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          Write-Output "ARCHIVE_FINAL_PATH_NAME (Windows): $path"

      # 3a. - Upload artifact to GitHub repos with API (Linux/macOS)
      - name: 4a. - Upload artifact to GitHub repos with API (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          FILE_TO_ADD=${{ env.ARCHIVE_FINAL_PATH_NAME }}
          echo "Uploading file '${FILE_TO_ADD}' to dev and prod repositories..."
          # Encode Artifact to Base64 (Linux/macOS)
          cat ${FILE_TO_ADD} | base64 | tr -d '\n' > artifact_base64.txt
          # Leer el contenido codificado en base64 desde el archivo
          BASE64_ARTIFACT=$(cat artifact_base64.txt)
          # Parameters
          COMMIT_MESSAGE="Added from GitHub Actions"
          REPOS=("OrganizeTakeoutPhotos-dev" "OrganizeTakeoutPhotos")
          for REPO in "${REPOS[@]}"; do
            echo "Uploading to $REPO..."
            URL=https://api.github.com/repos/jaimetur/$REPO/contents/${FILE_TO_ADD}
            # Extraer SHA si el archivo existe
            command="curl -s -f -H 'Authorization: token ${{ secrets.GH_PAT }}' '${URL}' | grep '\"sha\"' | awk -F '\"' '{print \$4}' || echo \"\""
            # echo "Command: ${command}"
            SHA=$(eval ${command})
            echo "SHA: ${SHA}"
            # Crear archivo temporal para el payload
            PAYLOAD_FILE=$(mktemp)
            # Generar el contenido del JSON y guardarlo en el archivo temporal
            echo "{
              \"message\": \"${COMMIT_MESSAGE}\",
              \"content\": \"${BASE64_ARTIFACT}\",
              \"branch\": \"main\",
              \"sha\": \"${SHA}\"
            }" > ${PAYLOAD_FILE}
            # Subir el archivo (crear o sobrescribir)
            curl -X PUT \
                -H "Authorization: token ${{ secrets.GH_PAT }}" \
                -H "Content-Type: application/json" \
                -d @${PAYLOAD_FILE} \
                ${URL}
            # Limpiar el archivo temporal
            rm ${PAYLOAD_FILE}
          done
        shell: bash

      # 3b. - Upload artifact to GitHub repos with API (Windows)
      - name: 4b. - Upload artifact to GitHub repos with API (Windows)
        if: runner.os == 'Windows'
        run: |
          $FILE_TO_ADD = $env:ARCHIVE_FINAL_PATH_NAME
          Write-Host "Uploading file '${FILE_TO_ADD}' to dev and prod repositories..."
          
          # Encode Artifact to Base64 (Windows)
          $BASE64_ARTIFACT = [Convert]::ToBase64String([IO.File]::ReadAllBytes("${FILE_TO_ADD}"))
          # Parameters
          $COMMIT_MESSAGE = "Added from GitHub Actions"
          $REPOS = @("OrganizeTakeoutPhotos-dev", "OrganizeTakeoutPhotos")
          foreach ($REPO in $REPOS) {
            Write-Host "Uploading to $REPO..."
            # Set URL
            $URL = "https://api.github.com/repos/jaimetur/$REPO/contents/${FILE_TO_ADD}"
            # Try to get the SHA of the existing file (if it exists)
            try {
              $SHA = (Invoke-RestMethod -Uri $URL -Headers @{Authorization="token ${{ secrets.GH_PAT }}"} -ErrorAction Stop).sha
            } catch {
              # If the file does not exist, SHA should be empty
              $SHA = $null
              Write-Host "File does not exist in $REPO. Creating new file."
            }
            # Create payload
            $Payload = @{
              message = $COMMIT_MESSAGE
              content = $BASE64_ARTIFACT
              branch = "main"
            }
            # Include SHA only if the file exists
            if ($SHA) {
              $Payload.sha = $SHA
            }
            # Convert payload to JSON
            $PayloadJson = $Payload | ConvertTo-Json -Compress
            # Upload the file (create or overwrite)
            Invoke-RestMethod -Method Put -Uri $URL -Headers @{Authorization="token ${{ secrets.GH_PAT }}"} -Body $PayloadJson
            Write-Host "File uploaded to $REPO successfully."
          }
        shell: pwsh

      # 4a. - Cleanup (Linux/macOS)
      - name: 5a. - Cleanup (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          if [ -f artifact_base64.txt ]; then
            rm artifact_base64.txt
            echo "Archivo artifact_base64.txt eliminado de carpeta raiz."
          elif [ -f src/artifact_base64.txt ]; then
            rm artifact_base64.txt
            echo "Archivo artifact_base64.txt eliminado de src."
          fi
          if [ -f ${{ env.ARCHIVE_FINAL_PATH_NAME }} ]; then
            rm ${{ env.ARCHIVE_FINAL_PATH_NAME }}
            echo "Archivo '${{ env.ARCHIVE_FINAL_PATH_NAME }}' eliminado de carpeta raiz."
          elif [ -f src/${{ env.ARCHIVE_FINAL_PATH_NAME }} ]; then
            rm ${{ env.ARCHIVE_FINAL_PATH_NAME }}
            echo "Archivo '${{ env.ARCHIVE_FINAL_PATH_NAME }}' eliminado de carpeta raiz."
          fi
        shell: bash

      # 4b. - Cleanup (Windows)
      - name: 6b. - Cleanup (Windows)
        if: runner.os == 'Windows'
        run: |
          if (Test-Path "artifact_base64.txt") {
            Remove-Item -Path "artifact_base64.txt"
            Write-Host "Archivo artifact_base64.txt eliminado de carpeta raiz."
          } 
          elseif (Test-Path "src\artifact_base64.txt") {
            Remove-Item -Path "src\artifact_base64.txt"
            Write-Host "Archivo artifact_base64.txt eliminado de carpeta src\."
          }
          if (Test-Path "${{ env.ARCHIVE_FINAL_PATH_NAME }}") {
            Remove-Item -Path "${{ env.ARCHIVE_FINAL_PATH_NAME }}"
            Write-Host "Archivo '${{ env.ARCHIVE_FINAL_PATH_NAME }}' eliminado de carpeta raiz."
          } 
          elseif (Test-Path "src\${{ env.ARCHIVE_FINAL_PATH_NAME }}") {
            Remove-Item -Path "src\${{ env.ARCHIVE_FINAL_PATH_NAME }}"
            Write-Host "Archivo '${{ env.ARCHIVE_FINAL_PATH_NAME }}' eliminado de carpeta src\."
          }
        shell: pwsh

      # 5. - Update README.md, RELEASES-NOTES.md, ROADMAP.md in prod repo with API
      - name: 5 - Update README.md, RELEASES-NOTES.md, ROADMAP.md in prod repo with API
        if: runner.os != 'Windows'
        run: |
          FILES_TO_ADD=("README.md" "RELEASES-NOTES.md" "ROADMAP.md")
          for FILE_TO_ADD in "${FILES_TO_ADD[@]}"; do
            echo "Uploading file '${FILE_TO_ADD}' to prod repository..."
            # Encode Artifact to Base64 (Linux/macOS)
            cat ${FILE_TO_ADD} | base64 | tr -d '\n' > artifact_base64.txt
            # Leer el contenido codificado en base64 desde el archivo
            BASE64_ARTIFACT=$(cat artifact_base64.txt)
            # Parameters
            COMMIT_MESSAGE="Added from GitHub Actions"
            REPOS=("OrganizeTakeoutPhotos")
            for REPO in "${REPOS[@]}"; do
              echo "Uploading to $REPO..."
              URL=https://api.github.com/repos/jaimetur/$REPO/contents/${FILE_TO_ADD} 
              # Extraer SHA si el archivo existe
              command="curl -s -f -H 'Authorization: token ${{ secrets.GH_PAT }}' '${URL}' | grep '\"sha\"' | awk -F '\"' '{print \$4}' || echo \"\""
              # echo "Command: ${command}"
              SHA=$(eval ${command})
              echo "SHA: ${SHA}"
              # Crear archivo temporal para el payload
              PAYLOAD_FILE=$(mktemp)
              # Generar el contenido del JSON y guardarlo en el archivo temporal
              echo "{
                \"message\": \"${COMMIT_MESSAGE}\",
                \"content\": \"${BASE64_ARTIFACT}\",
                \"branch\": \"main\",
                \"sha\": \"${SHA}\"
              }" > ${PAYLOAD_FILE}
              # Subir el archivo (crear o sobrescribir)
              curl -X PUT \
                  -H "Authorization: token ${{ secrets.GH_PAT }}" \
                  -H "Content-Type: application/json" \
                  -d @${PAYLOAD_FILE} \
                  ${URL}
              # Limpiar el archivo temporal
              rm ${PAYLOAD_FILE}
            done
          done
        shell: bash
        
#      # Upload artifact to GitHub repos with CLI (Cross-Platform)
#      - name: Upload artifact to GitHub repos with CLI (Cross-Platform)
#        run: |
#          echo "Uploading file '${{ env.ARCHIVE_FINAL_PATH_NAME }}' to dev and prod repositories..."
#
#          git config --global user.email "github-actions@github.com"
#          git config --global user.name "GitHub Actions"
#
#          COMMIT_MESSAGE="Added from GitHub Actions"
#          REPOS=("OrganizeTakeoutPhotos-dev" "OrganizeTakeoutPhotos")
#          FILE=${{ env.ARCHIVE_FINAL_PATH_NAME }}
#
#          for REPO in "${REPOS[@]}"; do
#            echo "Uploading to $REPO..."
#
#            REPO_URL="https://${{ secrets.GH_PAT }}@github.com/jaimetur/$REPO.git"
#
#            if [ ! -d ".git" ]; then
#              git init
#            fi
#
#            # Sobrescribe la URL de origin sin añadir duplicados
#            git remote set-url origin $REPO_URL
#
#            # Asegurar que estamos en la rama correcta
#            git fetch origin ${{ github.ref_name }} || git checkout -b ${{ github.ref_name }}
#            git checkout ${{ github.ref_name }}
#
#            # Añadir archivo y hacer commit
#            git add $FILE
#            git commit -m "$COMMIT_MESSAGE"
#
#            # Forzar el push (sobrescribe si es necesario)
#            git push origin ${{ github.ref_name }} --force
#          done

#      # Upload the compiled compressed file to the Actions task
#      - name: Archive Artifacts
#        uses: actions/upload-artifact@v4
#        with:
#          name: ${{ env.ARCHIVE_NAME }}
#          path: ${{ env.ARCHIVE_FINAL_PATH }}
