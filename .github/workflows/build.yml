name: Build Executables for Multiple Platforms

on:
  push:
    branches:
      - main
    paths-ignore:
      - '_built_versions/**'  # Ignore any changes in _built_versions
  workflow_dispatch:  # Allows manual execution of the workflow

jobs:
  build:
    strategy:
      matrix:
#        os: [ubuntu-20.04, macos-latest, windows-latest]  # macos-latest
#        os: [ubuntu-20.04]  # macos-latest
        os: [macos-latest]  # macos-latest
#        os: [ubuntu-20.04, windows-latest]  # macos-latest
#        os: [macos-latest, windows-latest]  # macos-latest
#        arch: [x86_64, arm64]  # amd64 and arm64
        arch: [arm64]  # amd64 and arm64
        exclude:
          - os: windows-latest
            arch: arm64  # Windows is only compiled for x86 (32/64-bit)
        python-version: ["3.10.10"]

    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v3

      - name: Show Matrix Info
        run: |
          echo "OS: ${{ matrix.os }}"
          echo "Architecture: ${{ matrix.arch }}"
        shell: bash

      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python-version }}

      # Compile for Linux with different architectures
      - name: Compile for Linux (arm64) with Docker and QEMU
        if: matrix.os == 'ubuntu-20.04' && matrix.arch == 'arm64'
        run: |
          apt update
          apt install -y qemu qemu-user-static
          docker run --rm --platform linux/arm64 -v ${{ github.workspace }}:/workspace -w /workspace/src python:3.10 bash -c "
                sudo apt update && sudo apt install -y gcc-aarch64-linux-gnu &&
                python3 _compile.py"
        shell: bash
      - name: Compile for Linux (amd64)
        if: matrix.os == 'ubuntu-20.04' && matrix.arch != 'arm64'
        run: |
          python3 _compile.py
        shell: bash

      # Compile for macOS with different architectures
      - name: Compile for MacOS (all architectures)
        if: matrix.os == 'macos-latest'
        run: |
          cd src
          arch -${{ matrix.arch }} python3 _compile.py
        shell: bash

      # Compile for Windows (and64)
      - name: Compile for Windows (amd64)
        if: matrix.os == 'windows-latest'
        run: |
          cd src
          python _compile.py
        shell: cmd

#      # Extract metadata and build paths
#      - name: Extract Metadata and Create Path Variables
#        run: |
#          SCRIPT_NAME=$(awk -F '"' '/SCRIPT_NAME/ {print $2}' src/OrganizeTakeoutPhotos.py)
#          SCRIPT_VERSION=$(awk -F '"' '/SCRIPT_VERSION/ {print $2}' src/OrganizeTakeoutPhotos.py)
#          SCRIPT_NAME_VERSION="${SCRIPT_NAME}_${SCRIPT_VERSION}"
#
#          ARCH="${{ matrix.arch }}"
#          OS_TAG="linux"  # Default value
#
#          # Determine tag based on the operating system
#          if [[ "${{ matrix.os }}" == *"windows"* ]]; then
#            OS_TAG="windows"
#          elif [[ "${{ matrix.os }}" == *"macos"* ]]; then
#            OS_TAG="macos"
#          fi
#
#          # Replace x86_64 with amd64
#          if [ "$ARCH" == "x86_64" ]; then
#            ARCH="amd64"
#          fi
#
#          # Create the artifact name with the dynamic tag
#          ARCHIVE_NAME="${SCRIPT_NAME_VERSION}_${OS_TAG}_${ARCH}.zip"
#
#          # Determine the path of the generated file
#          if [ -d "_built_versions/${SCRIPT_NAME_VERSION}" ]; then
#            ARCHIVE_PATH=$(realpath "_built_versions/${SCRIPT_NAME_VERSION}/")
#          else
#            ARCHIVE_PATH=$(pwd)/_built_versions/${SCRIPT_NAME_VERSION}
#          fi
#          ARCHIVE_PATH_NAME="${ARCHIVE_PATH}/${ARCHIVE_NAME}"
#          ARCHIVE_FINAL_PATH="_built_versions/${SCRIPT_NAME_VERSION}/"
#          ARCHIVE_FINAL_PATH_NAME="${ARCHIVE_FINAL_PATH}${ARCHIVE_NAME}"
#
#          # Print variables in screen
#          echo "ARCHIVE_NAME=${ARCHIVE_NAME}"
#          echo "ARCHIVE_PATH=${ARCHIVE_PATH}"
#          echo "ARCHIVE_PATH_NAME=${ARCHIVE_PATH_NAME}"
#          echo "ARCHIVE_FINAL_PATH=${ARCHIVE_FINAL_PATH}"
#          echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_FINAL_PATH_NAME}"
#
#          # Save variables in the environment
#          echo "ARCHIVE_NAME=${ARCHIVE_NAME}" >> $GITHUB_ENV
#          echo "ARCHIVE_PATH=${ARCHIVE_PATH}" >> $GITHUB_ENV
#          echo "ARCHIVE_PATH_NAME=${ARCHIVE_PATH_NAME}" >> $GITHUB_ENV
#          echo "ARCHIVE_FINAL_PATH=${ARCHIVE_FINAL_PATH}" >> $GITHUB_ENV
#          echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_FINAL_PATH_NAME}" >> $GITHUB_ENV
#
#          # For Windows, convert paths
#          if [ "$RUNNER_OS" == "Windows" ]; then
#            echo "ARCHIVE_PATH_NAME=$(echo ${ARCHIVE_PATH_NAME} | sed 's/\//\\/g')" >> $GITHUB_ENV
#          fi
#        shell: bash

      - name: Extract ARCHIVE_FINAL_PATH_NAME from filename.txt (Cross-Platform)
        run: |
          if [ "$RUNNER_OS" == "Windows" ]; then
            $path = Get-Content src/filename.txt | Select-String -Pattern "."
            echo "ARCHIVE_FINAL_PATH_NAME=$path" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            Write-Output "ARCHIVE_FINAL_PATH_NAME (Windows): $path"
          else
            ARCHIVE_PATH=$(cat src/filename.txt)
            echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_PATH}" >> $GITHUB_ENV
            echo "ARCHIVE_FINAL_PATH_NAME (Linux/macOS): ${ARCHIVE_PATH}"
          fi

      - name: Debug File Existence
        run: |
          ls -l _built_versions/OrganizeTakeoutPhotos_v2.3.0
          if [ ! -f ${{ env.ARCHIVE_FINAL_PATH_NAME }} ]; then
            echo "Error: Archivo no encontrado -> ${{ env.ARCHIVE_FINAL_PATH_NAME }}"
            exit 1
          fi
        shell: bash

      - name: Encode Artifact to Base64 (Linux/macOS/Windows)
        run: |
          base64 -w 0 ${{ env.ARCHIVE_FINAL_PATH_NAME }} > artifact_base64.txt
        shell: bash

      - name: Encode Artifact to Base64 (Windows)
        run: |
          [Convert]::ToBase64String([IO.File]::ReadAllBytes("${{ env.ARCHIVE_FINAL_PATH_NAME }}")) | Out-File -FilePath artifact_base64.txt
        shell: pwsh

      # Upload the compiled compressed file to the corresponding GitHub repositories
      - name: Upload artifact to GitHub repos (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          echo "Uploading file '${{ env.ARCHIVE_FINAL_PATH_NAME }}' to dev and prod repositories..."

          # Leer el contenido codificado en base64 desde el archivo (for Linux/macOS)
          BASE64_ARTIFACT=$(cat artifact_base64.txt)

          # Parameters
          COMMIT_MESSAGE="Added from GitHub Actions"

          # UPLOAD TO DEV REPO:
          URL=https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos-dev/contents/${{ env.ARCHIVE_FINAL_PATH_NAME }}
          # Realizar la solicitud y capturar la respuesta completa
          RESPONSE=$(curl -s -w "%{http_code}" -H "Authorization: token ${{ secrets.GH_PAT }}" ${URL})
      
          # Separar el cuerpo de la respuesta del código HTTP
          HTTP_CODE=$(echo "$RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
      
          # Si el archivo no existe (404), subir como nuevo (SHA=null)
          if [ "$HTTP_CODE" == "404" ]; then
            echo "Archivo no encontrado (404). Subiendo como nuevo..."
            SHA=null
          else
            # Extraer SHA si el archivo existe
            SHA=$(echo "$RESPONSE_BODY" | grep '"sha"' | awk -F '"' '{print $4}')
          fi
      
          # Subir el archivo (crear o sobrescribir)
          curl -X PUT \
            -H "Authorization: token ${{ secrets.GH_PAT }}" \
            -H "Content-Type: application/json" \
            -d @- ${URL} <<EOF
          {
            "message": "Added from GitHub Actions",
            "content": "${BASE64_ARTIFACT}",
            "branch": "main",
            "sha": ${SHA}
          }
          EOF

          # UPLOAD TO PROD REPO:
          URL=https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos/contents/${{ env.ARCHIVE_FINAL_PATH_NAME }}
          # Realizar la solicitud y capturar la respuesta completa
          RESPONSE=$(curl -s -w "%{http_code}" -H "Authorization: token ${{ secrets.GH_PAT }}" ${URL})
      
          # Separar el cuerpo de la respuesta del código HTTP
          HTTP_CODE=$(echo "$RESPONSE" | tail -n 1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
      
          # Si el archivo no existe (404), subir como nuevo (SHA=null)
          if [ "$HTTP_CODE" == "404" ]; then
            echo "Archivo no encontrado (404). Subiendo como nuevo..."
            SHA=null
          else
            # Extraer SHA si el archivo existe
            SHA=$(echo "$RESPONSE_BODY" | grep '"sha"' | awk -F '"' '{print $4}')
          fi
      
          # Subir el archivo (crear o sobrescribir)
          curl -X PUT \
            -H "Authorization: token ${{ secrets.GH_PAT }}" \
            -H "Content-Type: application/json" \
            -d @- ${URL} <<EOF
          {
            "message": "Added from GitHub Actions",
            "content": "${BASE64_ARTIFACT}",
            "branch": "main",
            "sha": ${SHA}
          }
          EOF
        shell: bash


      - name: Upload artifact to GitHub repos (Windows)
        if: runner.os == 'Windows'
        run: |
          Write-Host "Uploading file '${{ env.ARCHIVE_FINAL_PATH_NAME }}' to dev and prod repositories..."

          # Leer el contenido codificado en base64 (for Windows)
          $Base64Content = Get-Content -Path "artifact_base64.txt" -Raw

          # Parameters
          $COMMIT_MESSAGE = "Added from GitHub Actions"

          # UPLOAD TO DEV REPO:
          URL=https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos-dev/contents/${{ env.ARCHIVE_FINAL_PATH_NAME }}
          # Get the sha of the file in dev
          SHA = (Invoke-RestMethod -Uri "${URL}" -Headers @{Authorization="token ${{ secrets.GH_PAT }}"}).sha
          Invoke-RestMethod -Method Put -Uri "${URL}" -Headers @{Authorization="token ${{ secrets.GH_PAT }}"} -Body (ConvertTo-Json -Compress @{
            message = $COMMIT_MESSAGE
            content = $BASE64_ARTIFACT
            branch = "main"
            sha = SHA
          })

          # UPLOAD TO PROD REPO:
          URL=https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos/contents/${{ env.ARCHIVE_FINAL_PATH_NAME }}
          # Get the sha of the file in dev
          SHA = (Invoke-RestMethod -Uri "${URL}" -Headers @{Authorization="token ${{ secrets.GH_PAT }}"}).sha
          Invoke-RestMethod -Method Put -Uri "${URL}" -Headers @{Authorization="token ${{ secrets.GH_PAT }}"} -Body (ConvertTo-Json -Compress @{
            message = $COMMIT_MESSAGE
            content = $BASE64_ARTIFACT
            branch = "main"
            sha = SHA
          })
        shell: pwsh

      - name: Cleanup Base64 File (Linux/macOS)
        run: |
          rm artifact_base64.txt
        shell: bash

      - name: Cleanup Base64 File (Windows)
        run: |
          Remove-Item -Path "artifact_base64.txt"
        shell: pwsh


#      # Upload the compiled compressed file to the Actions task
#      - name: Archive Artifacts
#        uses: actions/upload-artifact@v4
#        with:
#          name: ${{ env.ARCHIVE_NAME }}
#          path: ${{ env.ARCHIVE_FINAL_PATH }}