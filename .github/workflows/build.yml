name: Build Executables for Multiple Platforms

on:
  push:
    branches:
      - main
    paths-ignore:
      - '_built_versions/**'  # Ignore any changes in _built_versions
  workflow_dispatch:  # Allows manual execution of the workflow

jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-20.04, macos-latest, windows-latest]  # macos-latest
#        os: [ubuntu-20.04]  # macos-latest
#        os: [macos-latest]  # macos-latest
#        os: [ubuntu-20.04, windows-latest]  # macos-latest
        arch: [x86_64, arm64]  # amd64 and arm64
#        arch: [arm64]  # amd64 and arm64
        exclude:
          - os: windows-latest
            arch: arm64  # Windows is only compiled for x86 (32/64-bit)
        python-version: ["3.10.10"]

    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v3

      - name: Show Matrix Info
        run: |
          echo "OS: ${{ matrix.os }}"
          echo "Architecture: ${{ matrix.arch }}"
        shell: bash

      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python-version }}

      # Compile for Linux with different architectures
      - name: Compile for Linux (arm64) with Docker and QEMU
        if: matrix.os == 'ubuntu-20.04' && matrix.arch == 'arm64'
        run: |
          sudo apt update
          sudo apt install -y qemu qemu-user-static
          docker run --rm --platform linux/arm64 -v ${{ github.workspace }}:/workspace -w /workspace/src python:3.10 bash -c "
            sudo apt update && sudo apt install -y gcc-aarch64-linux-gnu &&
            python3 _compile.py"
        shell: bash
      - name: Compile for Linux (amd64)
        if: matrix.os == 'ubuntu-20.04' && matrix.arch != 'arm64'
        run: |
          python3 _compile.py
        shell: bash

      # Compile for macOS with different architectures
      - name: Compile for MacOS (all architectures)
        if: matrix.os == 'macos-latest'
        run: |
          cd src
          arch=${{ matrix.arch }}
          if [ "$arch" = "arm64" ]; then
            arch -arm64 python3 _compile.py
          else
            arch -x86_64 python3 _compile.py
          fi
        shell: bash

      # Compile for Windows (and64)
      - name: Compile for Windows (amd64)
        if: matrix.os == 'windows-latest'
        run: |
          cd src
          python _compile.py
        shell: cmd

#      # Extract metadata and build paths
#      - name: Extract Metadata and Create Path Variables
#        run: |
#          SCRIPT_NAME=$(grep -oP 'SCRIPT_NAME\s*=\s*"\K[^"]+' src/OrganizeTakeoutPhotos.py)
#          SCRIPT_VERSION=$(grep -oP 'SCRIPT_VERSION\s*=\s*"\K[^"]+' src/OrganizeTakeoutPhotos.py)
#          SCRIPT_NAME_VERSION="${SCRIPT_NAME}_${SCRIPT_VERSION}"
#
#          ARCH="${{ matrix.arch }}"
#          OS_TAG="linux"  # Default value
#
#          # Determine tag based on the operating system
#          if [[ "${{ matrix.os }}" == *"windows"* ]]; then
#            OS_TAG="windows"
#          elif [[ "${{ matrix.os }}" == *"macos"* ]]; then
#            OS_TAG="macos"
#          fi
#
#          # Replace x86_64 with amd64
#          if [ "$ARCH" == "x86_64" ]; then
#            ARCH="amd64"
#          fi
#
#          # Create the artifact name with the dynamic tag
#          ARCHIVE_NAME="${SCRIPT_NAME_VERSION}_${OS_TAG}_${ARCH}.zip"
#
#          # Determine the path of the generated file
#          if [ -d "_built_versions/${SCRIPT_NAME_VERSION}" ]; then
#            ARCHIVE_PATH=$(realpath "_built_versions/${SCRIPT_NAME_VERSION}/")
#          else
#            ARCHIVE_PATH=$(pwd)/_built_versions/${SCRIPT_NAME_VERSION}
#          fi
#          ARCHIVE_PATH_NAME="${ARCHIVE_PATH}/${ARCHIVE_NAME}"
#          ARCHIVE_FINAL_PATH="_built_versions/${SCRIPT_NAME_VERSION}/"
#          ARCHIVE_FINAL_PATH_NAME="${ARCHIVE_FINAL_PATH}${ARCHIVE_NAME}"
#
#          # Print variables in screen
#          echo "ARCHIVE_NAME=${ARCHIVE_NAME}"
#          echo "ARCHIVE_PATH=${ARCHIVE_PATH}"
#          echo "ARCHIVE_PATH_NAME=${ARCHIVE_PATH_NAME}"
#          echo "ARCHIVE_FINAL_PATH=${ARCHIVE_FINAL_PATH}"
#          echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_FINAL_PATH_NAME}"
#
#          # Save variables in the environment
#          echo "ARCHIVE_NAME=${ARCHIVE_NAME}" >> $GITHUB_ENV
#          echo "ARCHIVE_PATH=${ARCHIVE_PATH}" >> $GITHUB_ENV
#          echo "ARCHIVE_PATH_NAME=${ARCHIVE_PATH_NAME}" >> $GITHUB_ENV
#          echo "ARCHIVE_FINAL_PATH=${ARCHIVE_FINAL_PATH}" >> $GITHUB_ENV
#          echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_FINAL_PATH_NAME}" >> $GITHUB_ENV
#
#          # For Windows, convert paths
#          if [ "$RUNNER_OS" == "Windows" ]; then
#            echo "ARCHIVE_PATH_NAME=$(echo ${ARCHIVE_PATH_NAME} | sed 's/\//\\/g')" >> $GITHUB_ENV
#          fi
#        shell: bash
#
#      # Upload the compiled compressed file to the corresponding GitHub repositories
#      - name: Upload artifact to GitHub repos
#        run: |
#          echo "Uploading file '${ARCHIVE_NAME}' to dev and prod repositories..."
#
#          # Convert the file to base64 (necessary for the GitHub API)
#          BASE64_ARTIFACT=$(base64 -w 0 ${{ env.ARCHIVE_PATH_NAME }})
#
#          # Parameters
#          COMMIT_MESSAGE="Added from GitHub Actions"
#
#          # Get the sha of the file in dev (if it exists)
#          SHA_DEV=$(curl -s -H "Authorization: token ${{ secrets.GH_PAT }}" \
#            https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos-dev/contents/${ARCHIVE_FINAL_PATH_NAME} | \
#            grep '"sha"' | awk -F '"' '{print $4}')
#
#          # Upload to dev repo (overwrite if it exists)
#          curl -X PUT \
#            -H "Authorization: token ${{ secrets.GH_PAT }}" \
#            -H "Content-Type: application/json" \
#            -d @- https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos-dev/contents/${ARCHIVE_FINAL_PATH_NAME} <<EOF
#          {
#            "message": "${COMMIT_MESSAGE}",
#            "content": "${BASE64_ARTIFACT}",
#            "branch": "${{ github.ref_name }}",
#            "sha": "${SHA_DEV}"
#          }
#          EOF
#
#          # Get the sha of the file in prod (if it exists)
#          SHA_PROD=$(curl -s -H "Authorization: token ${{ secrets.GH_PAT }}" \
#            https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos/contents/${ARCHIVE_FINAL_PATH_NAME} | \
#            grep '"sha"' | awk -F '"' '{print $4}')
#
#          # Upload to prod repo (overwrite if it exists)
#          curl -X PUT \
#            -H "Authorization: token ${{ secrets.GH_PAT }}" \
#            -H "Content-Type: application/json" \
#            -d @- https://api.github.com/repos/jaimetur/OrganizeTakeoutPhotos/contents/${ARCHIVE_FINAL_PATH_NAME} <<EOF
#          {
#            "message": "${COMMIT_MESSAGE}",
#            "content": "${BASE64_ARTIFACT}",
#            "branch": "${{ github.ref_name }}",
#            "sha": "${SHA_PROD}"
#          }
#          EOF


#      # Upload the compiled compressed file to the Actions task
#      - name: Archive Artifacts
#        uses: actions/upload-artifact@v4
#        with:
#          name: ${{ env.ARCHIVE_NAME }}
#          path: ${{ env.ARCHIVE_FINAL_PATH }}