name: Build Executables for Multiple Platforms

on:
  push:
    branches:
      - main
    paths-ignore:
      - '_built_versions/**'  # Ignora cualquier cambio en _built_versions
  workflow_dispatch:  # Permite ejecución manual del workflow

jobs:
  build:
    strategy:
      matrix:
#        os: [ubuntu-20.04, macos-latest, windows-latest]  # macos-latest
        os: [ubuntu-20.04]  # macos-latest
#        arch: [x86_64, arm64]  # amd64 y arm64
        arch: [x86_64]  # amd64 y arm64
        exclude:
          - os: windows-latest
            arch: arm64  # Windows solo se compila para x86 (32/64-bit)
        python-version: ["3.10.10"]

    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python-version }}

      # Compilación para Linux y macOS
      - name: Compile for Linux and MacOS
        if: matrix.os != 'windows-latest'
        run: |
          cd src
          python3 _compile.py
        shell: bash

      # Compilación para Windows
      - name: Compile for Windows
        if: matrix.os == 'windows-latest'
        run: |
          cd src
          python _compile.py
        shell: cmd

      # Extraer metadatos y construir paths
      - name: Extract Metadata and Create Path Variables
        run: |
          SCRIPT_NAME=$(grep -oP 'SCRIPT_NAME\s*=\s*"\K[^"]+' src/OrganizeTakeoutPhotos.py)
          SCRIPT_VERSION=$(grep -oP 'SCRIPT_VERSION\s*=\s*"\K[^"]+' src/OrganizeTakeoutPhotos.py)
          SCRIPT_NAME_VERSION="${SCRIPT_NAME}_${SCRIPT_VERSION}"

          ARCH="${{ matrix.arch }}"
          OS_TAG="linux"  # Valor por defecto

          # Determinar etiqueta según el sistema operativo
          if [[ "${{ matrix.os }}" == *"windows"* ]]; then
            OS_TAG="windows"
          elif [[ "${{ matrix.os }}" == *"macos"* ]]; then
            OS_TAG="macos"
          fi

          # Reemplazar x86_64 por amd64
          if [ "$ARCH" == "x86_64" ]; then
            ARCH="amd64"
          fi

          # Crear el nombre del artefacto con la etiqueta dinámica
          ARCHIVE_NAME="${SCRIPT_NAME_VERSION}_${OS_TAG}_${ARCH}.zip"
          
          # Determinar la ruta del archivo generado
          if [ -d "_built_versions/${SCRIPT_NAME_VERSION}" ]; then
            ARCHIVE_PATH=$(realpath "_built_versions/${SCRIPT_NAME_VERSION}/")
          else
            ARCHIVE_PATH=$(pwd)/_built_versions/${SCRIPT_NAME_VERSION}
          fi
          ARCHIVE_PATH_NAME="${ARCHIVE_PATH}/${ARCHIVE_NAME}"
          ARCHIVE_FINAL_PATH="_built_versions/${SCRIPT_NAME_VERSION}/"
          ARCHIVE_FINAL_PATH_NAME="${ARCHIVE_FINAL_PATH}${ARCHIVE_NAME}"
          
          # Guardar variables en el entorno
          echo "ARCHIVE_NAME=${ARCHIVE_NAME}"
          echo "ARCHIVE_PATH=${ARCHIVE_PATH}"
          echo "ARCHIVE_PATH_NAME=${ARCHIVE_PATH_NAME}"
          echo "ARCHIVE_FINAL_PATH=${ARCHIVE_FINAL_PATH}"
          echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_FINAL_PATH_NAME}"
          
          echo "ARCHIVE_NAME=${ARCHIVE_NAME}" >> $GITHUB_ENV
          echo "ARCHIVE_PATH=${ARCHIVE_PATH}" >> $GITHUB_ENV
          echo "ARCHIVE_PATH_NAME=${ARCHIVE_PATH_NAME}" >> $GITHUB_ENV
          echo "ARCHIVE_FINAL_PATH=${ARCHIVE_FINAL_PATH}" >> $GITHUB_ENV
          echo "ARCHIVE_FINAL_PATH_NAME=${ARCHIVE_FINAL_PATH_NAME}" >> $GITHUB_ENV

          # Para Windows, convertir rutas
          if [ "$RUNNER_OS" == "Windows" ]; then
            echo "ARCHIVE_PATH_NAME=$(echo ${ARCHIVE_PATH_NAME} | sed 's/\//\\/g')" >> $GITHUB_ENV
          fi
        shell: bash

      # Subir los ejecutables generados usando la ruta completa
      - name: Archive Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARCHIVE_NAME }}
          path: ${{ env.ARCHIVE_FINAL_PATH }}

      # Subir el fichero compilado comprimido a los repositorios Github correspondientes
      - name: Commit and push artifact to repos
        run: |
          echo "Archivo a original a subir: ${{ env.ARCHIVE_PATH_NAME }}"
          echo "Archivo final subido      : ${{ env.ARCHIVE_FINAL_PATH_NAME }}"

          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          mkdir -p temp-repo
          cd temp-repo

          git init

          git remote add dev https://${{ secrets.GH_PAT }}@github.com/jaimetur/OrganizeTakeoutPhotos-dev.git
          git remote add prod https://${{ secrets.GH_PAT }}@github.com/jaimetur/OrganizeTakeoutPhotos.git

          git fetch dev ${{ github.ref_name }} || git fetch dev main || git fetch dev master
          git checkout ${{ github.ref_name }} || git checkout main || git checkout -b ${{ github.ref_name }}

          # Rebase de dev y prod (omitimos conflictos)
          git pull dev ${{ github.ref_name }} --rebase || true
          git pull prod ${{ github.ref_name }} --rebase || (git rebase --skip || true)

          mkdir -p ${{ env.ARCHIVE_FINAL_PATH }}
          cp -r ${{ env.ARCHIVE_PATH_NAME }} ${{ env.ARCHIVE_FINAL_PATH }}

          if [ -d "${{ env.ARCHIVE_FINAL_PATH }}" ]; then
            git add ${{ env.ARCHIVE_FINAL_PATH }}
            git commit -m "Added from GitHub Actions"

            git branch -m ${{ github.ref_name }}

            git push dev ${{ github.ref_name }}
            git push prod ${{ github.ref_name }}
          else
            echo "Error: El directorio ${{ env.ARCHIVE_FINAL_PATH }} no existe. No se realizará el commit."
            exit 1
          fi
      
      
      
      
      
      
