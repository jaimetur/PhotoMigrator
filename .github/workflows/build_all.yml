name: Build Binaries for Multiple Platforms and Docker Image

on:
  workflow_dispatch:
    inputs:
      compiler:
        description: "Select Compiler:"
        required: true
        default: "nuitka"
        type: choice
        options:
          - nuitka
          - pyinstaller
      mode:
        description: "Select Mode:"
        required: true
        default: "global"
        type: choice
        options:
          - global
          - custom
      python:
        description: "Select Python Version:"
        required: true
        default: "3.12"
        type: choice
        options:
          - "3.8"
          - "3.9"
          - "3.10"
          - "3.11"
          - "3.12"
          - "3.13"
          - "3.14"
      linux_x64:
        description: "Include linux-x64?"
        type: boolean
        required: false
        default: 'true'
      linux_arm64:
        description: "Include linux-arm64?"
        type: boolean
        required: false
        default: true
      macos_x64:
        description: "Include macos-x64?"
        type: boolean
        required: false
        default: true
      macos_arm64:
        description: "Include macos-arm64?"
        type: boolean
        required: false
        default: true
      windows_x64:
        description: "Include windows-x64?"
        type: boolean
        required: false
        default: true
      windows_arm64:
        description: "Include windows-arm64?"
        type: boolean
        required: false
        default: true
#      os:
#        description: "Comma-separated list of OS (e.g., ubuntu-x64,macos-x64,...)"
#        required: true
#        default: "linux-x64,linux-arm64,macos-x64,macos-arm64,windows-x64,windows-arm64"

  #push:                   # Ejecución tras push en main, excepto en los path-ignore
    #branches:
      #- main
    #paths-ignore:
      #- '_built_versions/**'  # Ignore any changes in _built_versions
      #- .gitignore
      #- gpth*/**
      #- exif*/**
      #- .idea/**
      #- _src_versions/**
      #- _buildt_versions/**
      #- .github/**
#  schedule:
# Ejecución diaria a las 2 AM UTC
#    - cron: '0 2 * * *'


jobs:
  set-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set.outputs.matrix }}
    steps:
      - id: set
        run: |
          # Inputs convertidos a strings válidos
          linux_x64=${{ toJSON(github.event.inputs.linux_x64) }}
          linux_arm64=${{ toJSON(github.event.inputs.linux_arm64) }}
          macos_x64=${{ toJSON(github.event.inputs.macos_x64) }}
          macos_arm64=${{ toJSON(github.event.inputs.macos_arm64) }}
          windows_x64=${{ toJSON(github.event.inputs.windows_x64) }}
          windows_arm64=${{ toJSON(github.event.inputs.windows_arm64) }}

          # Crear lista
          OS_LIST=()
          [ "$linux_x64" = "true" ] && OS_LIST+=("linux-x64")
          [ "$linux_arm64" = "true" ] && OS_LIST+=("linux-arm64")
          [ "$macos_x64" = "true" ] && OS_LIST+=("macos-x64")
          [ "$macos_arm64" = "true" ] && OS_LIST+=("macos-arm64")
          [ "$windows_x64" = "true" ] && OS_LIST+=("windows-x64")
          [ "$windows_arm64" = "true" ] && OS_LIST+=("windows-arm64")

          if [ ${#OS_LIST[@]} -eq 0 ]; then
            echo "❌ No OS selected"
            exit 1
          fi

          # Convertir a array JSON real y limpio
          OS_JSON=$(printf '%s\n' "${OS_LIST[@]}" | jq -R . | jq -s .)

          # Construir JSON compacto final
          MATRIX=$(jq -nc \
            --argjson os "$OS_JSON" \
            --arg compiler "${{ github.event.inputs.compiler }}" \
            --arg mode "${{ github.event.inputs.mode }}" \
            --arg python "${{ github.event.inputs.python }}" \
            '{os: $os, compiler: [$compiler], mode: [$mode], python: [$python]}')

          echo "✅ Matriz generada:"
          echo "$MATRIX"

          # Exportar en una sola línea (obligatorio)
          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
          

  build:
    # Different VM images to compile in all SO and all Archs according to:
    # https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners#standard-github-hosted-runners-for-public-repositories
    strategy:
      matrix: ${{ fromJson(needs.set-matrix.outputs.matrix) }}
        # os: [ linux-x64, linux-arm64, macos-x64, macos-arm64, windows-x64, windows-arm64 ]
        # compiler: [ "${{ github.event.inputs.compiler }}" ] # possible values: [pyinstaller, nuitka]
        # mode: [ "${{ github.event.inputs.mode }}" ] # possible values: [global, custom]
        # python: [ "${{ github.event.inputs.python }}"] # select Python version

    # runs-on: ${{ matrix.os }}
    # latest linux-x64: ubuntu-latest
    # latest linux-arm64: ubuntu-24.04-arm
    runs-on: ${{ fromJson('{
      "linux-x64":"ubuntu-22.04", 
      "linux-arm64":"ubuntu-22.04-arm",
      "macos-x64":"macos-13",
      "macos-arm64":"macos-latest",
      "windows-x64":"windows-latest",
      "windows-arm64":"windows-11-arm"}')
      [matrix.os] }}

    steps:
      - name: Show runner OS, Arch, Python, Compiler, Mode
        run: |
          echo "OS: ${{ runner.os }}"
          echo "Arch: ${{ runner.arch }}"
          echo "Python: ${{ matrix.python }}"
          echo "Compiler: ${{ matrix.compiler }}"
          echo "Build Mode: ${{ matrix.mode }}"

      # Checkout Repository
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.TOKEN_GITHUB }}

      # Set up Python
      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python }}

      # Install dependencies
      - name: Install dependencies
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install -r requirements.txt

#      - name: Install Visual Studio Build Tools (MSVC)
#        if: runner.os == 'Windows'
#        uses: ilammy/msvc-dev-cmd@v1

      # 1a. - GLOBAL - Build for All Operating System (Linux, MacOS, Windows) and All Architectures (x64, arm64)
      - name: 1a. - GLOBAL - Build for All Operating System (Linux, MacOS, Windows) and All Architectures (x64, arm64)
        if: matrix.mode == 'global' && contains(github.event.inputs.os, matrix.os)
        run: |
          echo "::group::Build for ${{ runner.os }}-${{ runner.arch }}. Python Version: ${{ matrix.python }}. Compiler: ${{ matrix.compiler }}"
          echo "================================================================================================="
          echo "INFO    : INSTALLED VERSIONS..."
          echo "================================================================================================="
          echo "Python version:"
          python3 --version
          echo "PyInstaller version:"
          pyinstaller --version
          echo "Nuitka version:"
          python3 -m nuitka --version
          echo "================================================================================================="
          echo "INFO    : COMPILING..."
          echo "================================================================================================="
          python3 build.py --${{ matrix.compiler }} --onefile

          echo "::endgroup::"
        shell: bash

      # 1b. - CUSTOM - Build for All Operating System (Linux, MacOS, Windows) and All Architectures (x64, arm64)
      - name: 1b. - CUSTOM - Build for All Operating System (Linux, MacOS, Windows) and All Architectures (x64, arm64)
        if: matrix.mode == 'custom' && contains(github.event.inputs.os, matrix.os)
        run: |
          echo "::group::Build for ${{ runner.os }}-${{ runner.arch }}. Python Version: ${{ matrix.python }}. Compiler: ${{ matrix.compiler }}"
           
          # Build for Linux (x64)
          if [[ "${{ matrix.os }}" == *"linux"* ]] && [ "${{ runner.arch }}" == "X64" ]; then
            docker run --rm --platform linux/amd64 -v ${{ github.workspace }}:/workspace -w /workspace jaimetur/centos-amd64:7 bash -c '
                # echo "================================================================================================="
                # echo "INFO    : INSTALLING REQUIREMENTS..."
                # echo "================================================================================================="
                # python3 -m pip install --upgrade pip
                # python3 -m pip install -r requirements.txt
                echo "================================================================================================="
                echo "INFO    : INSTALLED VERSIONS..."
                echo "================================================================================================="
                echo "Python version:"
                python3 --version
                echo "PyInstaller version:"
                pyinstaller --version
                echo "Nuitka version:"
                python3 -m nuitka --version
                echo "================================================================================================="
                echo "INFO    : COMPILING..."
                echo "================================================================================================="
                python3 build.py --${{ matrix.compiler }} --onefile
            '
          # Build for Linux (arm64), macOS (x64 & arm64), Windows (x64 & arm64)
          else; then
            # echo "================================================================================================="
            # echo "INFO    : INSTALLING REQUIREMENTS..."
            # echo "================================================================================================="
            # python3 -m pip install --upgrade pip
            # python3 -m pip install -r requirements.txt
            echo "================================================================================================="
            echo "INFO    : INSTALLED VERSIONS..."
            echo "================================================================================================="
            echo "Python version:"
            python3 --version
            echo "PyInstaller version:"
            pyinstaller --version
            echo "Nuitka version:"
            python3 -m nuitka --version
            echo "================================================================================================="
            echo "INFO    : COMPILING..."
            echo "================================================================================================="
            python3 build.py --${{ matrix.compiler }} --onefile
          
          fi

          echo "::endgroup::"
        shell: bash

      # 2a. Read SCRIPT_VERSION and ARCHIVE_PATH from build_info.txt (Linux/macOS)
      - name: 2a. Read SCRIPT_VERSION and ARCHIVE_PATH from build_info.txt (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          # Read SCRIPT_VERSION from the first line
          SCRIPT_VERSION=$(grep '^SCRIPT_VERSION=' build_info.txt | cut -d'=' -f2-)

          # Read ARCHIVE_PATH from the second line
          ARCHIVE_PATH=$(grep '^ARCHIVE_PATH=' build_info.txt | cut -d'=' -f2-)
          
          # Save both variables on GitHub Actions environment
          echo "SCRIPT_VERSION=${SCRIPT_VERSION}" >> $GITHUB_ENV
          echo "ARCHIVE_PATH=${ARCHIVE_PATH}" >> $GITHUB_ENV

          # Print both variables on screen
          echo "SCRIPT_VERSION (Linux/macOS): ${SCRIPT_VERSION}"
          echo "ARCHIVE_PATH (Linux/macOS)  : ${ARCHIVE_PATH}"

      # 2b. Read SCRIPT_VERSION and ARCHIVE_PATH from build_info.txt (Windows)
      - name: 2b. Read SCRIPT_VERSION and ARCHIVE_PATH from build_info.txt (Windows)
        if: runner.os == 'Windows'
        run: |
          # Cargar todas las líneas del archivo como un diccionario clave=valor
          $info = @{}
          Get-Content build_info.txt | ForEach-Object {
              if ($_ -match '^([^=]+)=(.*)$') {
                  $info[$matches[1]] = $matches[2]
              }
          }
          
          # Acceder a los valores
          $SCRIPT_VERSION = $info['SCRIPT_VERSION']
          $ARCHIVE_PATH = $info['ARCHIVE_PATH'] -replace '\\', '/'

          # Save both variables on GitHub Actions environment
          echo "SCRIPT_VERSION=$SCRIPT_VERSION" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "ARCHIVE_PATH=$ARCHIVE_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

          # Print both variables on screen
          Write-Output "SCRIPT_VERSION (Windows): $SCRIPT_VERSION"
          Write-Output "ARCHIVE_PATH (Windows)  : $ARCHIVE_PATH"


      # ===========================
      # Generate the Docker version
      # ===========================
      # 3. Log in to Docker Hub
      - name: 3. Log in to Docker Hub
        if: ${{ startsWith(matrix.os, 'linux') && runner.arch == 'X64' }}
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
          
      # 4. Build & Push Docker image
      - name: 4. Build & Push Docker image
        if: ${{ startsWith(matrix.os, 'linux') && runner.arch == 'X64' }}
        run: |
          # Fuerza a Docker a:
          #  1) descargar la base actualizada ( --pull )
          #  2) ignorar todas las capas cacheadas ( --no-cache )
          docker build --pull --no-cache \
            -t jaimetur/photomigrator:${{ env.SCRIPT_VERSION }} \
            -f docker/Dockerfile .

          # Etiquetar como latest
          docker tag jaimetur/photomigrator:${{ env.SCRIPT_VERSION }} jaimetur/photomigrator:latest

          # Si es versión estable (no alpha, beta ni RC), etiquetar también como latest-stable
          if [[ "${SCRIPT_VERSION}" != *alpha* && "${SCRIPT_VERSION}" != *beta* && "${SCRIPT_VERSION}" != *RC* ]]; then
            docker tag jaimetur/photomigrator:${SCRIPT_VERSION} jaimetur/photomigrator:latest-stable
            docker push jaimetur/photomigrator:latest-stable
          fi

          # Subir etiquetas latest y con versión específica
          docker push jaimetur/photomigrator:${SCRIPT_VERSION}
          docker push jaimetur/photomigrator:latest

      # 5. Prepare unified ZIP docker package
      - name: 5. Prepare unified ZIP docker package
        if: ${{ startsWith(matrix.os, 'linux') && runner.arch == 'X64' }}
        run: |
          mkdir -p PhotoMigrator/docker
          cp docker/PhotoMigrator.sh PhotoMigrator/docker/
          cp docker/PhotoMigrator.bat PhotoMigrator/docker/
          cp docker/docker.conf PhotoMigrator/docker/
          cp Config.ini PhotoMigrator/docker/
          cp -r docs PhotoMigrator/docker/
          cp -r help PhotoMigrator/docker/
          cp README.md PhotoMigrator/docker/docs/README.md
          zip -r PhotoMigrator_v${{ env.SCRIPT_VERSION }}_docker.zip PhotoMigrator
      # ================================
      # End of Docker version Generation
      # ================================

      # 6. Create Release and Upload Artifact to it
      - name: 6. Create Release and Upload Artifacts to it
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.SCRIPT_VERSION }}
          name: v${{ env.SCRIPT_VERSION }}
          draft: false
          prerelease: true
          generate_release_notes: true
          body_path: CURRENT-RELEASE.md
          files: |
            PhotoMigrator_v${{ env.SCRIPT_VERSION }}_docker.zip
            ${{ env.ARCHIVE_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN_GITHUB }}

      # 7. Commit y push README.md (Solo si OS = Ubuntu* y arch = x64)
      - name: 7. Commit y push README.md
        if: ${{ startsWith(matrix.os, 'linux') && runner.arch == 'X64' }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Añadir solo README.md, evitando archivos no deseados
          git add README.md

          # Si NO hay cambios en README.md, salir sin error
          if git diff --cached --quiet; then
            echo "No hay cambios en README.md"
            exit 0
          fi

          # Guardar cambios en stash antes de pull --rebase
          git stash push -m "Pre-rebase stash"

          # Actualizar la rama
          git pull --rebase origin ${{ github.ref_name }}

          # Restaurar cambios del stash si existen
          git stash pop || echo "No hay stash para aplicar"

          # Asegurar que README.md está agregado después del pop
          git add README.md

          # Verificar nuevamente si hay cambios antes de hacer commit
          if git diff --cached --quiet; then
            echo "No hay cambios después del stash pop"
            exit 0
          fi

          # Realizar commit y push
          git commit -m "README.md updated by Github Actions (build_all.yml)"
          git push origin ${{ github.ref_name }}
        
      # 8a. - Cleanup (Linux/macOS)
      - name: 8a. - Cleanup (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          if [ -f artifact_base64.txt ]; then
            rm artifact_base64.txt
            echo "Archivo artifact_base64.txt eliminado de carpeta raiz."
          elif [ -f src/artifact_base64.txt ]; then
            rm artifact_base64.txt
            echo "Archivo artifact_base64.txt eliminado de src."
          fi
          # if [ -f ${{ env.ARCHIVE_PATH }} ]; then
            # rm ${{ env.ARCHIVE_PATH }}
            # echo "Archivo '${{ env.ARCHIVE_PATH }}' eliminado de carpeta raiz."
          # elif [ -f src/${{ env.ARCHIVE_PATH }} ]; then
            # rm ${{ env.ARCHIVE_PATH }}
            # echo "Archivo '${{ env.ARCHIVE_PATH }}' eliminado de carpeta src."
          # fi
        shell: bash

      # 8b. - Cleanup (Windows)
      - name: 8b. - Cleanup (Windows)
        if: runner.os == 'Windows'
        run: |
          if (Test-Path "artifact_base64.txt") {
            Remove-Item -Path "artifact_base64.txt"
            Write-Host "Archivo artifact_base64.txt eliminado de carpeta raiz."
          } 
          elseif (Test-Path "src\artifact_base64.txt") {
            Remove-Item -Path "src\artifact_base64.txt"
            Write-Host "Archivo artifact_base64.txt eliminado de carpeta src\."
          }
          if (Test-Path "${{ env.ARCHIVE_PATH }}") {
            Remove-Item -Path "${{ env.ARCHIVE_PATH }}"
            Write-Host "Archivo '${{ env.ARCHIVE_PATH }}' eliminado de carpeta raiz."
          } 
          elseif (Test-Path "src\${{ env.ARCHIVE_PATH }}") {
            Remove-Item -Path "src\${{ env.ARCHIVE_PATH }}"
            Write-Host "Archivo '${{ env.ARCHIVE_PATH }}' eliminado de carpeta src\."
          }
        shell: pwsh
