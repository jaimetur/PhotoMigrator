name: Build Docker Image and Binaries for Multiple Platforms

on:
  workflow_dispatch:      # Allows manual execution of the workflow
  #push:                   # Ejecución tras push en main, excepto en los path-ignore
    #branches:
      #- main
    #paths-ignore:
      #- '_built_versions/**'  # Ignore any changes in _built_versions
      #- .gitignore
      #- gpth*/**
      #- exif*/**
      #- .idea/**
      #- _src_versions/**
      #- _buildt_versions/**
      #- .github/**
#  schedule:
# Ejecución diaria a las 2 AM UTC
#    - cron: '0 2 * * *'

jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]  # os list
#        os: [ubuntu-latest]  # os list
        arch: [x86_64, arm64]  # arch list
#        arch: [x86_64]  # arch list
        exclude:
          - os: windows-latest
            arch: arm64  # Windows is only compiled for x86 (32/64-bit)
        python-version: ["3.12.3"]

    runs-on: ${{ matrix.os }}

    steps:
      # Checkout Repository
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.TOKEN_GITHUB }}

      # Set up Python
      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python-version }}

      # 1. - Compile for All Operating System (Linux, MacOS, Windows) and All Architectures (amd64, arm64)
      - name: 1. - Compile for All Operating System (Linux, MacOS, Windows) and All Architectures (amd64, arm64)
        run: |
          echo "::group::Compile for ${{ matrix.os }} - ${{ matrix.arch }}"
                    
          # Compile for macOS (any architecture)
          if [[ "${{ matrix.os }}" == *"macos"* ]]; then
            cd src
            arch -${{ matrix.arch }} python3 _compile.py
          
          # Compile for Windows (amd64)
          elif [[ "${{ matrix.os }}" == *"windows"* ]]; then
            cd src
            python _compile.py
               
          # Compile for Linux (arm64)
          elif [[ "${{ matrix.os }}" == *"ubuntu"* ]] && [ "${{ matrix.arch }}" == "arm64" ]; then
            sudo apt-get update
            sudo apt-get install -y software-properties-common
            sudo add-apt-repository universe
            sudo add-apt-repository multiverse
            sudo add-apt-repository restricted
            sudo apt-get update
            sudo apt-get install -y qemu-user-static binfmt-support
            docker run --rm --platform linux/arm64 -v ${{ github.workspace }}:/workspace -w /workspace/src ubuntu:20.04 bash -c "
                apt update && apt install -y gcc-aarch64-linux-gnu python3 python3-pip &&
                python3 _compile.py
                "
          
          # Compile for Linux (amd64)
          elif [[ "${{ matrix.os }}" == *"ubuntu"* ]] && [ "${{ matrix.arch }}" != "arm64" ]; then
            docker run --rm --platform linux/amd64 -v ${{ github.workspace }}:/workspace -w /workspace/src jaimetur/centos-amd64:7 bash -c "
                cd src
                python3 _compile.py
                "
          fi

          echo "::endgroup::"
        shell: bash

      # 2a. Read SCRIPT_VERSION and ARCHIVE_PATH from script_info.txt (Linux/macOS)
      - name: 2a. Read SCRIPT_VERSION and ARCHIVE_PATH from script_info.txt (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          # Read SCRIPT_VERSION from the first line
          SCRIPT_VERSION=$(sed -n '1p' script_info.txt)

          # Read ARCHIVE_PATH from the second line
          ARCHIVE_PATH=$(sed -n '2p' script_info.txt)

          # Save both variables on GitHub Actions environment
          echo "SCRIPT_VERSION=${SCRIPT_VERSION}" >> $GITHUB_ENV
          echo "ARCHIVE_PATH=${ARCHIVE_PATH}" >> $GITHUB_ENV

          # Print both variables on screen
          echo "SCRIPT_VERSION (Linux/macOS): ${SCRIPT_VERSION}"
          echo "ARCHIVE_PATH (Linux/macOS)  : ${ARCHIVE_PATH}"

      # 2b. Read SCRIPT_VERSION and ARCHIVE_PATH from script_info.txt (Windows)
      - name: 2b. Read SCRIPT_VERSION and ARCHIVE_PATH from script_info.txt (Windows)
        if: runner.os == 'Windows'
        run: |
          # Read SCRIPT_VERSION from the first line
          $SCRIPT_VERSION = Get-Content script_info.txt | Select-Object -First 1

          # Read ARCHIVE_PATH from the second line and replace '\' by '/'
          $ARCHIVE_PATH = (Get-Content script_info.txt | Select-Object -Skip 1 -First 1) -replace '\\', '/'
          # $ARCHIVE_PATH = Get-Content script_info.txt | Select-String -Pattern "."

          # Save both variables on GitHub Actions environment
          echo "SCRIPT_VERSION=$SCRIPT_VERSION" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "ARCHIVE_PATH=$ARCHIVE_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

          # Print both variables on screen
          Write-Output "SCRIPT_VERSION (Windows): $SCRIPT_VERSION"
          Write-Output "ARCHIVE_PATH (Windows)  : $ARCHIVE_PATH"


      # 3. Create Release and Upload Artifact to it
      - name: 3. Create Release and Upload Artifact to it
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.SCRIPT_VERSION }}
          draft: true
          generate_release_notes: true
          body_path: CURRENT-RELEASE.md
          files: |
            ${{ env.ARCHIVE_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN_GITHUB }}

      # ===========================
      # Generate the Docker version
      # ===========================
      - name: Log in to Docker Hub
        if: ${{ startsWith(matrix.os, 'ubuntu') && matrix.arch == 'x86_64' }}
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
          

      - name: Build & Push Docker image
        if: ${{ startsWith(matrix.os, 'ubuntu') && matrix.arch == 'x86_64' }}
        run: |
          # Fuerza a Docker a:
          #  1) descargar la base actualizada ( --pull )
          #  2) ignorar todas las capas cacheadas ( --no-cache )
          docker build --pull --no-cache \
            -t jaimetur/cloudphotomigrator:${{ env.SCRIPT_VERSION }} \
            -f docker/Dockerfile .
              
          # Etiquetar también como latest
          docker tag jaimetur/cloudphotomigrator:${{ env.SCRIPT_VERSION }} jaimetur/cloudphotomigrator:latest
      
          # Subir ambas etiquetas
          docker push jaimetur/cloudphotomigrator:${{ env.SCRIPT_VERSION }}
          docker push jaimetur/cloudphotomigrator:latest


      - name: Prepare unified ZIP docker package
        if: ${{ startsWith(matrix.os, 'ubuntu') && matrix.arch == 'x86_64' }}
        run: |
          mkdir -p CloudPhotoMigrator/docker
          cp docker/CloudPhotoMigrator.sh CloudPhotoMigrator/docker/
          cp docker/CloudPhotoMigrator.bat CloudPhotoMigrator/docker/
          cp docker/docker.conf CloudPhotoMigrator/docker/
          cp Config.ini CloudPhotoMigrator/docker/
          cp -r docs CloudPhotoMigrator/docker/
          cp -r help CloudPhotoMigrator/docker/
          cp README.md CloudPhotoMigrator/docker/docs/README.md
          zip -r CloudPhotoMigrator_v${{ env.SCRIPT_VERSION }}_docker.zip CloudPhotoMigrator

      - name: Upload release asset
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.SCRIPT_VERSION }}
          draft: true
          generate_release_notes: true
          body_path: CURRENT-RELEASE.md
          files: |
            CloudPhotoMigrator_v${{ env.SCRIPT_VERSION }}_docker.zip
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN_GITHUB }}

        
      # 4a. - Cleanup (Linux/macOS)
      - name: 4a. - Cleanup (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          if [ -f artifact_base64.txt ]; then
            rm artifact_base64.txt
            echo "Archivo artifact_base64.txt eliminado de carpeta raiz."
          elif [ -f src/artifact_base64.txt ]; then
            rm artifact_base64.txt
            echo "Archivo artifact_base64.txt eliminado de src."
          fi
          # if [ -f ${{ env.ARCHIVE_PATH }} ]; then
            # rm ${{ env.ARCHIVE_PATH }}
            # echo "Archivo '${{ env.ARCHIVE_PATH }}' eliminado de carpeta raiz."
          # elif [ -f src/${{ env.ARCHIVE_PATH }} ]; then
            # rm ${{ env.ARCHIVE_PATH }}
            # echo "Archivo '${{ env.ARCHIVE_PATH }}' eliminado de carpeta src."
          # fi
        shell: bash

      # 4b. - Cleanup (Windows)
      - name: 4b. - Cleanup (Windows)
        if: runner.os == 'Windows'
        run: |
          if (Test-Path "artifact_base64.txt") {
            Remove-Item -Path "artifact_base64.txt"
            Write-Host "Archivo artifact_base64.txt eliminado de carpeta raiz."
          } 
          elseif (Test-Path "src\artifact_base64.txt") {
            Remove-Item -Path "src\artifact_base64.txt"
            Write-Host "Archivo artifact_base64.txt eliminado de carpeta src\."
          }
          if (Test-Path "${{ env.ARCHIVE_PATH }}") {
            Remove-Item -Path "${{ env.ARCHIVE_PATH }}"
            Write-Host "Archivo '${{ env.ARCHIVE_PATH }}' eliminado de carpeta raiz."
          } 
          elseif (Test-Path "src\${{ env.ARCHIVE_PATH }}") {
            Remove-Item -Path "src\${{ env.ARCHIVE_PATH }}"
            Write-Host "Archivo '${{ env.ARCHIVE_PATH }}' eliminado de carpeta src\."
          }
        shell: pwsh

      # 5. Commit y push README.md (Solo si OS = Ubuntu* y arch = x86_64)
      - name: 5. Commit y push README.md
        if: ${{ startsWith(matrix.os, 'ubuntu') && matrix.arch == 'x86_64' }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Añadir solo README.md, evitando archivos no deseados
          git add README.md

          # Si NO hay cambios en README.md, salir sin error
          if git diff --cached --quiet; then
            echo "No hay cambios en README.md"
            exit 0
          fi

          # Guardar cambios en stash antes de pull --rebase
          git stash push -m "Pre-rebase stash"

          # Actualizar la rama
          git pull --rebase origin ${{ github.ref_name }}

          # Restaurar cambios del stash si existen
          git stash pop || echo "No hay stash para aplicar"

          # Asegurar que README.md está agregado después del pop
          git add README.md

          # Verificar nuevamente si hay cambios antes de hacer commit
          if git diff --cached --quiet; then
            echo "No hay cambios después del stash pop"
            exit 0
          fi

          # Realizar commit y push
          git commit -m "Actualizar README.md tras compilación"
          git push origin ${{ github.ref_name }}



#      # 3. Commit and tag
#      - name: 3. Commit and tag
#        id: push-tag
#        uses: EndBug/add-and-commit@v9
#        with:
#          default_author: github_actions
#          message: 'SCRIPT_VERSION: ${{ env.SCRIPT_VERSION }}'
#          tag: ${{ env.SCRIPT_VERSION }}
#          push: true
#        env:
#          TOKEN_GITHUB: ${{ secrets.TOKEN_GITHUB }}
#
#      # 4a. - Upload artifact to GitHub repos with API (Linux/macOS)
#      - name: 4a. - Upload artifact to GitHub repos with API (Linux/macOS)
#        if: runner.os != 'Windows'
#        run: |
#          FILE_TO_ADD=${{ env.ARCHIVE_PATH }}
#          echo "Uploading file '${FILE_TO_ADD}' to dev and prod repositories..."
#          # Encode Artifact to Base64 (Linux/macOS)
#          cat ${FILE_TO_ADD} | base64 | tr -d '\n' > artifact_base64.txt
#          # Leer el contenido codificado en base64 desde el archivo
#          BASE64_ARTIFACT=$(cat artifact_base64.txt)
#          # Parameters
#          COMMIT_MESSAGE="Added from GitHub Actions"
#          REPOS=("CloudPhotoMigrator-dev" "CloudPhotoMigrator")
#          for REPO in "${REPOS[@]}"; do
#            echo "Uploading to $REPO..."
#            URL=https://api.github.com/repos/jaimetur/$REPO/contents/${FILE_TO_ADD}
#            # Extraer SHA si el archivo existe
#            command="curl -s -f -H 'Authorization: token ${{ secrets.TOKEN_GITHUB }}' '${URL}' | grep '\"sha\"' | awk -F '\"' '{print \$4}' || echo \"\""
#            # echo "Command: ${command}"
#            SHA=$(eval ${command})
#            echo "SHA: ${SHA}"
#            # Crear archivo temporal para el payload
#            PAYLOAD_FILE=$(mktemp)
#            # Generar el contenido del JSON y guardarlo en el archivo temporal
#            echo "{
#              \"message\": \"${COMMIT_MESSAGE}\",
#              \"content\": \"${BASE64_ARTIFACT}\",
#              \"branch\": \"main\",
#              \"sha\": \"${SHA}\"
#            }" > ${PAYLOAD_FILE}
#            # Subir el archivo (crear o sobrescribir)
#            curl -X PUT \
#                -H "Authorization: token ${{ secrets.TOKEN_GITHUB }}" \
#                -H "Content-Type: application/json" \
#                -d @${PAYLOAD_FILE} \
#                ${URL}
#            # Limpiar el archivo temporal
#            rm ${PAYLOAD_FILE}
#          done
#        shell: bash
#
#      # 4b. - Upload artifact to GitHub repos with API (Windows)
#      - name: 4b. - Upload artifact to GitHub repos with API (Windows)
#        if: runner.os == 'Windows'
#        run: |
#          $FILE_TO_ADD = $env:ARCHIVE_PATH
#          Write-Host "Uploading file '${FILE_TO_ADD}' to dev and prod repositories..."
#
#          # Encode Artifact to Base64 (Windows)
#          $BASE64_ARTIFACT = [Convert]::ToBase64String([IO.File]::ReadAllBytes("${FILE_TO_ADD}"))
#          # Parameters
#          $COMMIT_MESSAGE = "Added from GitHub Actions"
#          $REPOS = @("CloudPhotoMigrator-dev", "CloudPhotoMigrator")
#          foreach ($REPO in $REPOS) {
#            Write-Host "Uploading to $REPO..."
#            # Set URL
#            $URL = "https://api.github.com/repos/jaimetur/$REPO/contents/${FILE_TO_ADD}"
#            # Try to get the SHA of the existing file (if it exists)
#            try {
#              $SHA = (Invoke-RestMethod -Uri $URL -Headers @{Authorization="token ${{ secrets.TOKEN_GITHUB }}"} -ErrorAction Stop).sha
#            } catch {
#              # If the file does not exist, SHA should be empty
#              $SHA = $null
#              Write-Host "File does not exist in $REPO. Creating new file."
#            }
#            # Create payload
#            $Payload = @{
#              message = $COMMIT_MESSAGE
#              content = $BASE64_ARTIFACT
#              branch = "main"
#            }
#            # Include SHA only if the file exists
#            if ($SHA) {
#              $Payload.sha = $SHA
#            }
#            # Convert payload to JSON
#            $PayloadJson = $Payload | ConvertTo-Json -Compress
#            # Upload the file (create or overwrite)
#            Invoke-RestMethod -Method Put -Uri $URL -Headers @{Authorization="token ${{ secrets.TOKEN_GITHUB }}"} -Body $PayloadJson
#            Write-Host "File uploaded to $REPO successfully."
#          }
#        shell: pwsh
#
#      # 5. - Update README.md, RELEASES-NOTES.md, ROADMAP.md in prod repo with API
#      - name: 5 - Update README.md, RELEASES-NOTES.md, ROADMAP.md in prod repo with API
#        if: runner.os != 'Windows'
#        run: |
#          FILES_TO_ADD=("README.md" "RELEASES-NOTES.md" "ROADMAP.md")
#          for FILE_TO_ADD in "${FILES_TO_ADD[@]}"; do
#            echo "Uploading file '${FILE_TO_ADD}' to prod repository..."
#            # Encode Artifact to Base64 (Linux/macOS)
#            cat ${FILE_TO_ADD} | base64 | tr -d '\n' > artifact_base64.txt
#            # Leer el contenido codificado en base64 desde el archivo
#            BASE64_ARTIFACT=$(cat artifact_base64.txt)
#            # Parameters
#            COMMIT_MESSAGE="Added from GitHub Actions"
#            REPOS=("CloudPhotoMigrator")
#            for REPO in "${REPOS[@]}"; do
#              echo "Uploading to $REPO..."
#              URL=https://api.github.com/repos/jaimetur/$REPO/contents/${FILE_TO_ADD}
#              # Extraer SHA si el archivo existe
#              command="curl -s -f -H 'Authorization: token ${{ secrets.TOKEN_GITHUB }}' '${URL}' | grep '\"sha\"' | awk -F '\"' '{print \$4}' || echo \"\""
#              # echo "Command: ${command}"
#              SHA=$(eval ${command})
#              echo "SHA: ${SHA}"
#              # Crear archivo temporal para el payload
#              PAYLOAD_FILE=$(mktemp)
#              # Generar el contenido del JSON y guardarlo en el archivo temporal
#              echo "{
#                \"message\": \"${COMMIT_MESSAGE}\",
#                \"content\": \"${BASE64_ARTIFACT}\",
#                \"branch\": \"main\",
#                \"sha\": \"${SHA}\"
#              }" > ${PAYLOAD_FILE}
#              # Subir el archivo (crear o sobrescribir)
#              curl -X PUT \
#                  -H "Authorization: token ${{ secrets.TOKEN_GITHUB }}" \
#                  -H "Content-Type: application/json" \
#                  -d @${PAYLOAD_FILE} \
#                  ${URL}
#              # Limpiar el archivo temporal
#              rm ${PAYLOAD_FILE}
#            done
#          done
#        shell: bash
#
#      # Upload the compiled compressed file to the Actions task
#      - name: Archive Artifacts
#        uses: actions/upload-artifact@v4
#        with:
#          name: ${{ env.ARCHIVE_NAME }}
#          path: ${{ env.ARCHIVE_PATH }}
